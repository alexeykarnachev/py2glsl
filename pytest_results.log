(py2glsl) akarnachev@computer:~/proj/py2glsl$ pytest tests/test_shader_hoisting.py 
================================================================================ test session starts ================================================================================
platform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/akarnachev/proj/py2glsl
configfile: pyproject.toml
plugins: asyncio-0.25.3, cov-6.0.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=function
collected 11 items                                                                                                                                                                  

tests/test_shader_hoisting.py F.F.FFFFFFF                                                                                                                                     [100%]

===================================================================================== FAILURES ======================================================================================
___________________________________________________________________________ test_basic_variable_hoisting ____________________________________________________________________________

    def test_basic_variable_hoisting():
        """Test basic variable hoisting at function scope"""
    
        def shader(vs_uv: vec2) -> vec4:
            x = 1.0
            return vec4(x, 0.0, 0.0, 1.0)
    
        result = py2glsl(shader)
        assert "float x;" in result.fragment_source
        assert "x = 1.0;" in result.fragment_source
    
        # Verify shader compiles and runs
>       arr = render_array(shader, size=(64, 64))

tests/test_shader_hoisting.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
py2glsl/render.py:60: in render_array
    program = ctx.program(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <moderngl.Context object at 0x7fd26a22ecf0>
vertex_shader = '#version 460\nlayout(location = 0) in vec2 in_pos;\nlayout(location = 1) in vec2 in_uv;\nout vec2 vs_uv;\n\nvoid main() {\n    gl_Position = vec4(in_pos, 0.0, 1.0);\n    vs_uv = in_uv;\n}'
fragment_shader = '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    float x;\n\n    float x = 1.0;\n    return vec4(x, 0.0, 0.0, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}'
geometry_shader = None, tess_control_shader = None, tess_evaluation_shader = None, varyings = (), fragment_outputs = {}, attributes = None, varyings_capture_mode = 'interleaved'

    def program(
        self,
        vertex_shader=None,
        fragment_shader=None,
        geometry_shader=None,
        tess_control_shader=None,
        tess_evaluation_shader=None,
        varyings=(),
        fragment_outputs=None,
        attributes=None,
        varyings_capture_mode="interleaved",
    ):
        if varyings_capture_mode not in ("interleaved", "separate"):
            raise ValueError("varyings_capture_mode must be interleaved or separate")
    
        if type(varyings) is str:
            varyings = (varyings,)
    
        varyings = tuple(varyings)
    
        if fragment_outputs is None:
            fragment_outputs = {}
    
        if isinstance(vertex_shader, str):
            vertex_shader = vertex_shader.strip()
    
        if isinstance(fragment_shader, str):
            fragment_shader = fragment_shader.strip()
    
        res = Program.__new__(Program)
>       res.mglo, _members, res._subroutines, res._geom, res._glo = self.mglo.program(
            vertex_shader,
            fragment_shader,
            geometry_shader,
            tess_control_shader,
            tess_evaluation_shader,
            None,
            varyings,
            fragment_outputs,
            varyings_capture_mode == "interleaved",
        )
E       _moderngl.Error: GLSL Compiler failed
E       
E       fragment_shader
E       ===============
E       0:10(8): error: `x' redeclared

.venv/lib/python3.13/site-packages/moderngl/__init__.py:1978: Error
------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------
2025-02-10 16:23:51.697 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        x = 1.0
        return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:51.697 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    x = 1.0
    return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:51.697 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:51.697 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=1.0)),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Constant(value=0.0),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:51.697 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:51.697 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    float x;

    float x = 1.0;
    return vec4(x, 0.0, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:51.697 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
2025-02-10 16:23:51.735 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        x = 1.0
        return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:51.735 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    x = 1.0
    return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:51.735 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:51.735 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=1.0)),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Constant(value=0.0),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:51.735 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:51.735 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    float x;

    float x = 1.0;
    return vec4(x, 0.0, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:51.735 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
_____________________________________________________________________________ test_loop_scope_hoisting ______________________________________________________________________________

    def test_loop_scope_hoisting():
        """Test variable hoisting from loop scope"""
    
        def shader(vs_uv: vec2) -> vec4:
            sum = 0.0
            for i in range(4):
                x = float(i)
                sum += x
            return vec4(sum, 0.0, 0.0, 1.0)
    
        result = py2glsl(shader)
        assert "float sum;" in result.fragment_source
        assert "float x;" in result.fragment_source
        assert "sum = 0.0;" in result.fragment_source
        assert "x = float(i);" in result.fragment_source
    
        # Verify shader compiles and runs
>       arr = render_array(shader, size=(64, 64))

tests/test_shader_hoisting.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
py2glsl/render.py:60: in render_array
    program = ctx.program(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <moderngl.Context object at 0x7fd253c17890>
vertex_shader = '#version 460\nlayout(location = 0) in vec2 in_pos;\nlayout(location = 1) in vec2 in_uv;\nout vec2 vs_uv;\n\nvoid main() {\n    gl_Position = vec4(in_pos, 0.0, 1.0);\n    vs_uv = in_uv;\n}'
fragment_shader = '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    int i;\n    float sum;\n    flo...n        sum += x;\n    }\n    return vec4(sum, 0.0, 0.0, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}'
geometry_shader = None, tess_control_shader = None, tess_evaluation_shader = None, varyings = (), fragment_outputs = {}, attributes = None, varyings_capture_mode = 'interleaved'

    def program(
        self,
        vertex_shader=None,
        fragment_shader=None,
        geometry_shader=None,
        tess_control_shader=None,
        tess_evaluation_shader=None,
        varyings=(),
        fragment_outputs=None,
        attributes=None,
        varyings_capture_mode="interleaved",
    ):
        if varyings_capture_mode not in ("interleaved", "separate"):
            raise ValueError("varyings_capture_mode must be interleaved or separate")
    
        if type(varyings) is str:
            varyings = (varyings,)
    
        varyings = tuple(varyings)
    
        if fragment_outputs is None:
            fragment_outputs = {}
    
        if isinstance(vertex_shader, str):
            vertex_shader = vertex_shader.strip()
    
        if isinstance(fragment_shader, str):
            fragment_shader = fragment_shader.strip()
    
        res = Program.__new__(Program)
>       res.mglo, _members, res._subroutines, res._geom, res._glo = self.mglo.program(
            vertex_shader,
            fragment_shader,
            geometry_shader,
            tess_control_shader,
            tess_evaluation_shader,
            None,
            varyings,
            fragment_outputs,
            varyings_capture_mode == "interleaved",
        )
E       _moderngl.Error: GLSL Compiler failed
E       
E       fragment_shader
E       ===============
E       0:12(8): error: `sum' redeclared

.venv/lib/python3.13/site-packages/moderngl/__init__.py:1978: Error
------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------
2025-02-10 16:23:51.816 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        sum = 0.0
        for i in range(4):
            x = float(i)
            sum += x
        return vec4(sum, 0.0, 0.0, 1.0)

2025-02-10 16:23:51.816 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    sum = 0.0
    for i in range(4):
        x = float(i)
        sum += x
    return vec4(sum, 0.0, 0.0, 1.0)

2025-02-10 16:23:51.816 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:51.816 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='sum', ctx=Store())],
          value=Constant(value=0.0)),
        For(
          target=Name(id='i', ctx=Store()),
          iter=Call(
            func=Name(id='range', ctx=Load()),
            args=[
              Constant(value=4)]),
          body=[
            Assign(
              targets=[
                Name(id='x', ctx=Store())],
              value=Call(
                func=Name(id='float', ctx=Load()),
                args=[
                  Name(id='i', ctx=Load())])),
            AugAssign(
              target=Name(id='sum', ctx=Store()),
              op=Add(),
              value=Name(id='x', ctx=Load()))]),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='sum', ctx=Load()),
              Constant(value=0.0),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:51.816 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:51.817 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    int i;
    float sum;
    float x;

    float sum = 0.0;
    for (int i = 0; i < 4; i++)
    {
        float x = float(i);
        sum += x;
    }
    return vec4(sum, 0.0, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:51.817 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
2025-02-10 16:23:51.843 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        sum = 0.0
        for i in range(4):
            x = float(i)
            sum += x
        return vec4(sum, 0.0, 0.0, 1.0)

2025-02-10 16:23:51.843 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    sum = 0.0
    for i in range(4):
        x = float(i)
        sum += x
    return vec4(sum, 0.0, 0.0, 1.0)

2025-02-10 16:23:51.843 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:51.843 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='sum', ctx=Store())],
          value=Constant(value=0.0)),
        For(
          target=Name(id='i', ctx=Store()),
          iter=Call(
            func=Name(id='range', ctx=Load()),
            args=[
              Constant(value=4)]),
          body=[
            Assign(
              targets=[
                Name(id='x', ctx=Store())],
              value=Call(
                func=Name(id='float', ctx=Load()),
                args=[
                  Name(id='i', ctx=Load())])),
            AugAssign(
              target=Name(id='sum', ctx=Store()),
              op=Add(),
              value=Name(id='x', ctx=Load()))]),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='sum', ctx=Load()),
              Constant(value=0.0),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:51.843 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:51.843 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    int i;
    float sum;
    float x;

    float sum = 0.0;
    for (int i = 0; i < 4; i++)
    {
        float x = float(i);
        sum += x;
    }
    return vec4(sum, 0.0, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:51.843 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
__________________________________________________________________________ test_multiple_variable_hoisting __________________________________________________________________________

    def test_multiple_variable_hoisting():
        """Test hoisting of multiple variables"""
    
        def shader(vs_uv: vec2) -> vec4:
            x = 1.0
            y = 2.0
            v2 = vec2(x, y)
            v3 = vec3(v2, 3.0)
            return vec4(v3, 1.0)
    
        result = py2glsl(shader)
        assert "float x;" in result.fragment_source
        assert "float y;" in result.fragment_source
        assert "vec2 v2;" in result.fragment_source
        assert "vec3 v3;" in result.fragment_source
    
        # Verify shader compiles and runs
>       arr = render_array(shader, size=(64, 64))

tests/test_shader_hoisting.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
py2glsl/render.py:60: in render_array
    program = ctx.program(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <moderngl.Context object at 0x7fd25351a060>
vertex_shader = '#version 460\nlayout(location = 0) in vec2 in_pos;\nlayout(location = 1) in vec2 in_uv;\nout vec2 vs_uv;\n\nvoid main() {\n    gl_Position = vec4(in_pos, 0.0, 1.0);\n    vs_uv = in_uv;\n}'
fragment_shader = '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    vec2 v2;\n    vec3 v3;\n    flo...x, y);\n    vec3 v3 = vec3(v2, 3.0);\n    return vec4(v3, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}'
geometry_shader = None, tess_control_shader = None, tess_evaluation_shader = None, varyings = (), fragment_outputs = {}, attributes = None, varyings_capture_mode = 'interleaved'

    def program(
        self,
        vertex_shader=None,
        fragment_shader=None,
        geometry_shader=None,
        tess_control_shader=None,
        tess_evaluation_shader=None,
        varyings=(),
        fragment_outputs=None,
        attributes=None,
        varyings_capture_mode="interleaved",
    ):
        if varyings_capture_mode not in ("interleaved", "separate"):
            raise ValueError("varyings_capture_mode must be interleaved or separate")
    
        if type(varyings) is str:
            varyings = (varyings,)
    
        varyings = tuple(varyings)
    
        if fragment_outputs is None:
            fragment_outputs = {}
    
        if isinstance(vertex_shader, str):
            vertex_shader = vertex_shader.strip()
    
        if isinstance(fragment_shader, str):
            fragment_shader = fragment_shader.strip()
    
        res = Program.__new__(Program)
>       res.mglo, _members, res._subroutines, res._geom, res._glo = self.mglo.program(
            vertex_shader,
            fragment_shader,
            geometry_shader,
            tess_control_shader,
            tess_evaluation_shader,
            None,
            varyings,
            fragment_outputs,
            varyings_capture_mode == "interleaved",
        )
E       _moderngl.Error: GLSL Compiler failed
E       
E       fragment_shader
E       ===============
E       0:13(8): error: `x' redeclared
E       0:14(8): error: `y' redeclared
E       0:15(7): error: `v2' redeclared
E       0:16(7): error: `v3' redeclared

.venv/lib/python3.13/site-packages/moderngl/__init__.py:1978: Error
------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------
2025-02-10 16:23:51.906 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        x = 1.0
        y = 2.0
        v2 = vec2(x, y)
        v3 = vec3(v2, 3.0)
        return vec4(v3, 1.0)

2025-02-10 16:23:51.906 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    x = 1.0
    y = 2.0
    v2 = vec2(x, y)
    v3 = vec3(v2, 3.0)
    return vec4(v3, 1.0)

2025-02-10 16:23:51.907 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:51.907 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=1.0)),
        Assign(
          targets=[
            Name(id='y', ctx=Store())],
          value=Constant(value=2.0)),
        Assign(
          targets=[
            Name(id='v2', ctx=Store())],
          value=Call(
            func=Name(id='vec2', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Name(id='y', ctx=Load())])),
        Assign(
          targets=[
            Name(id='v3', ctx=Store())],
          value=Call(
            func=Name(id='vec3', ctx=Load()),
            args=[
              Name(id='v2', ctx=Load()),
              Constant(value=3.0)])),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='v3', ctx=Load()),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:51.907 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:51.907 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    vec2 v2;
    vec3 v3;
    float x;
    float y;

    float x = 1.0;
    float y = 2.0;
    vec2 v2 = vec2(x, y);
    vec3 v3 = vec3(v2, 3.0);
    return vec4(v3, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:51.907 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
2025-02-10 16:23:51.932 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        x = 1.0
        y = 2.0
        v2 = vec2(x, y)
        v3 = vec3(v2, 3.0)
        return vec4(v3, 1.0)

2025-02-10 16:23:51.932 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    x = 1.0
    y = 2.0
    v2 = vec2(x, y)
    v3 = vec3(v2, 3.0)
    return vec4(v3, 1.0)

2025-02-10 16:23:51.932 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:51.933 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=1.0)),
        Assign(
          targets=[
            Name(id='y', ctx=Store())],
          value=Constant(value=2.0)),
        Assign(
          targets=[
            Name(id='v2', ctx=Store())],
          value=Call(
            func=Name(id='vec2', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Name(id='y', ctx=Load())])),
        Assign(
          targets=[
            Name(id='v3', ctx=Store())],
          value=Call(
            func=Name(id='vec3', ctx=Load()),
            args=[
              Name(id='v2', ctx=Load()),
              Constant(value=3.0)])),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='v3', ctx=Load()),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:51.933 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:51.933 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    vec2 v2;
    vec3 v3;
    float x;
    float y;

    float x = 1.0;
    float y = 2.0;
    vec2 v2 = vec2(x, y);
    vec3 v3 = vec3(v2, 3.0);
    return vec4(v3, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:51.933 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
___________________________________________________________________________ test_function_scope_isolation ___________________________________________________________________________

    def test_function_scope_isolation():
        """Test variable isolation between functions"""
    
        def shader(vs_uv: vec2) -> vec4:
            def func1() -> float:
                x = 1.0  # Should be isolated
                return x
    
            def func2() -> float:
                x = 2.0  # Different x
                return x
    
            return vec4(func1() + func2(), 0.0, 0.0, 1.0)
    
        result = py2glsl(shader)
        func1_part = result.fragment_source[
            result.fragment_source.find("func1") : result.fragment_source.find("func2")
        ]
        func2_part = result.fragment_source[result.fragment_source.find("func2") :]
    
        assert "float x;" in func1_part
        assert "float x;" in func2_part
    
        # Verify shader compiles and runs
>       arr = render_array(shader, size=(64, 64))

tests/test_shader_hoisting.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
py2glsl/render.py:60: in render_array
    program = ctx.program(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <moderngl.Context object at 0x7fd253561250>
vertex_shader = '#version 460\nlayout(location = 0) in vec2 in_pos;\nlayout(location = 1) in vec2 in_uv;\nout vec2 vs_uv;\n\nvoid main() {\n    gl_Position = vec4(in_pos, 0.0, 1.0);\n    vs_uv = in_uv;\n}'
fragment_shader = '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nfloat func1()\n{\n    float x;\n\n    float x = 1.0;\n    retur...n x;\n    }\n    return vec4(func1() + func2(), 0.0, 0.0, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}'
geometry_shader = None, tess_control_shader = None, tess_evaluation_shader = None, varyings = (), fragment_outputs = {}, attributes = None, varyings_capture_mode = 'interleaved'

    def program(
        self,
        vertex_shader=None,
        fragment_shader=None,
        geometry_shader=None,
        tess_control_shader=None,
        tess_evaluation_shader=None,
        varyings=(),
        fragment_outputs=None,
        attributes=None,
        varyings_capture_mode="interleaved",
    ):
        if varyings_capture_mode not in ("interleaved", "separate"):
            raise ValueError("varyings_capture_mode must be interleaved or separate")
    
        if type(varyings) is str:
            varyings = (varyings,)
    
        varyings = tuple(varyings)
    
        if fragment_outputs is None:
            fragment_outputs = {}
    
        if isinstance(vertex_shader, str):
            vertex_shader = vertex_shader.strip()
    
        if isinstance(fragment_shader, str):
            fragment_shader = fragment_shader.strip()
    
        res = Program.__new__(Program)
>       res.mglo, _members, res._subroutines, res._geom, res._glo = self.mglo.program(
            vertex_shader,
            fragment_shader,
            geometry_shader,
            tess_control_shader,
            tess_evaluation_shader,
            None,
            varyings,
            fragment_outputs,
            varyings_capture_mode == "interleaved",
        )
E       _moderngl.Error: GLSL Compiler failed
E       
E       fragment_shader
E       ===============
E       0:25(2): error: syntax error, unexpected '{', expecting ';'

.venv/lib/python3.13/site-packages/moderngl/__init__.py:1978: Error
------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------
2025-02-10 16:23:51.962 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        def func1() -> float:
            x = 1.0  # Should be isolated
            return x

        def func2() -> float:
            x = 2.0  # Different x
            return x

        return vec4(func1() + func2(), 0.0, 0.0, 1.0)

2025-02-10 16:23:51.962 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    def func1() -> float:
        x = 1.0  # Should be isolated
        return x

    def func2() -> float:
        x = 2.0  # Different x
        return x

    return vec4(func1() + func2(), 0.0, 0.0, 1.0)

2025-02-10 16:23:51.962 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:51.962 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        FunctionDef(
          name='func1',
          args=arguments(),
          body=[
            Assign(
              targets=[
                Name(id='x', ctx=Store())],
              value=Constant(value=1.0)),
            Return(
              value=Name(id='x', ctx=Load()))],
          returns=Name(id='float', ctx=Load())),
        FunctionDef(
          name='func2',
          args=arguments(),
          body=[
            Assign(
              targets=[
                Name(id='x', ctx=Store())],
              value=Constant(value=2.0)),
            Return(
              value=Name(id='x', ctx=Load()))],
          returns=Name(id='float', ctx=Load())),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              BinOp(
                left=Call(
                  func=Name(id='func1', ctx=Load())),
                op=Add(),
                right=Call(
                  func=Name(id='func2', ctx=Load()))),
              Constant(value=0.0),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:51.962 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:51.962 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

float func1()
{
    float x;

    float x = 1.0;
    return x;
}

float func2()
{
    float x;

    float x = 2.0;
    return x;
}

vec4 shader(vec2 vs_uv)
{
    float func1()
    {
        x = 1.0;
        return x;
    }
    float func2()
    {
        x = 2.0;
        return x;
    }
    return vec4(func1() + func2(), 0.0, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:51.962 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
2025-02-10 16:23:51.988 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        def func1() -> float:
            x = 1.0  # Should be isolated
            return x

        def func2() -> float:
            x = 2.0  # Different x
            return x

        return vec4(func1() + func2(), 0.0, 0.0, 1.0)

2025-02-10 16:23:51.988 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    def func1() -> float:
        x = 1.0  # Should be isolated
        return x

    def func2() -> float:
        x = 2.0  # Different x
        return x

    return vec4(func1() + func2(), 0.0, 0.0, 1.0)

2025-02-10 16:23:51.989 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:51.989 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        FunctionDef(
          name='func1',
          args=arguments(),
          body=[
            Assign(
              targets=[
                Name(id='x', ctx=Store())],
              value=Constant(value=1.0)),
            Return(
              value=Name(id='x', ctx=Load()))],
          returns=Name(id='float', ctx=Load())),
        FunctionDef(
          name='func2',
          args=arguments(),
          body=[
            Assign(
              targets=[
                Name(id='x', ctx=Store())],
              value=Constant(value=2.0)),
            Return(
              value=Name(id='x', ctx=Load()))],
          returns=Name(id='float', ctx=Load())),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              BinOp(
                left=Call(
                  func=Name(id='func1', ctx=Load())),
                op=Add(),
                right=Call(
                  func=Name(id='func2', ctx=Load()))),
              Constant(value=0.0),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:51.989 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:51.989 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

float func1()
{
    float x;

    float x = 1.0;
    return x;
}

float func2()
{
    float x;

    float x = 2.0;
    return x;
}

vec4 shader(vec2 vs_uv)
{
    float func1()
    {
        x = 1.0;
        return x;
    }
    float func2()
    {
        x = 2.0;
        return x;
    }
    return vec4(func1() + func2(), 0.0, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:51.989 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
______________________________________________________________________ test_reused_variable_single_declaration ______________________________________________________________________

    def test_reused_variable_single_declaration():
        """Test that reused variables are only declared once"""
    
        def shader(vs_uv: vec2) -> vec4:
            x = 1.0
            x = 2.0  # Reuse
            x = 3.0  # Reuse again
            return vec4(x, 0.0, 0.0, 1.0)
    
        result = py2glsl(shader)
        assert result.fragment_source.count("float x;") == 1
        assert result.fragment_source.count("x =") == 3
    
        # Verify shader compiles and runs
>       arr = render_array(shader, size=(64, 64))

tests/test_shader_hoisting.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
py2glsl/render.py:60: in render_array
    program = ctx.program(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <moderngl.Context object at 0x7fd2535a4af0>
vertex_shader = '#version 460\nlayout(location = 0) in vec2 in_pos;\nlayout(location = 1) in vec2 in_uv;\nout vec2 vs_uv;\n\nvoid main() {\n    gl_Position = vec4(in_pos, 0.0, 1.0);\n    vs_uv = in_uv;\n}'
fragment_shader = '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    float x;\n\n    float x = 1.0;\n    x = 2.0;\n    x = 3.0;\n    return vec4(x, 0.0, 0.0, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}'
geometry_shader = None, tess_control_shader = None, tess_evaluation_shader = None, varyings = (), fragment_outputs = {}, attributes = None, varyings_capture_mode = 'interleaved'

    def program(
        self,
        vertex_shader=None,
        fragment_shader=None,
        geometry_shader=None,
        tess_control_shader=None,
        tess_evaluation_shader=None,
        varyings=(),
        fragment_outputs=None,
        attributes=None,
        varyings_capture_mode="interleaved",
    ):
        if varyings_capture_mode not in ("interleaved", "separate"):
            raise ValueError("varyings_capture_mode must be interleaved or separate")
    
        if type(varyings) is str:
            varyings = (varyings,)
    
        varyings = tuple(varyings)
    
        if fragment_outputs is None:
            fragment_outputs = {}
    
        if isinstance(vertex_shader, str):
            vertex_shader = vertex_shader.strip()
    
        if isinstance(fragment_shader, str):
            fragment_shader = fragment_shader.strip()
    
        res = Program.__new__(Program)
>       res.mglo, _members, res._subroutines, res._geom, res._glo = self.mglo.program(
            vertex_shader,
            fragment_shader,
            geometry_shader,
            tess_control_shader,
            tess_evaluation_shader,
            None,
            varyings,
            fragment_outputs,
            varyings_capture_mode == "interleaved",
        )
E       _moderngl.Error: GLSL Compiler failed
E       
E       fragment_shader
E       ===============
E       0:10(8): error: `x' redeclared

.venv/lib/python3.13/site-packages/moderngl/__init__.py:1978: Error
------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------
2025-02-10 16:23:52.018 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        x = 1.0
        x = 2.0  # Reuse
        x = 3.0  # Reuse again
        return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:52.018 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    x = 1.0
    x = 2.0  # Reuse
    x = 3.0  # Reuse again
    return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:52.018 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:52.018 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=1.0)),
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=2.0)),
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=3.0)),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Constant(value=0.0),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:52.018 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:52.018 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    float x;

    float x = 1.0;
    x = 2.0;
    x = 3.0;
    return vec4(x, 0.0, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:52.018 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
2025-02-10 16:23:52.044 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        x = 1.0
        x = 2.0  # Reuse
        x = 3.0  # Reuse again
        return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:52.044 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    x = 1.0
    x = 2.0  # Reuse
    x = 3.0  # Reuse again
    return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:52.044 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:52.044 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=1.0)),
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=2.0)),
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=3.0)),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Constant(value=0.0),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:52.044 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:52.044 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    float x;

    float x = 1.0;
    x = 2.0;
    x = 3.0;
    return vec4(x, 0.0, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:52.044 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
_________________________________________________________________________ test_hoisting_with_immediate_init _________________________________________________________________________

    def test_hoisting_with_immediate_init():
        """Test variables are not redeclared when hoisted and immediately initialized"""
    
        def shader(vs_uv: vec2) -> vec4:
            x = 1.0  # Should be hoisted and initialized in one statement
            return vec4(x, 0.0, 0.0, 1.0)
    
        result = py2glsl(shader)
>       assert result.fragment_source.count("float x") == 1
E       AssertionError: assert 2 == 1
E        +  where 2 = <built-in method count of str object at 0x7fd253c273c0>('float x')
E        +    where <built-in method count of str object at 0x7fd253c273c0> = '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    float x;\n\n    float x = 1.0;\n    return vec4(x, 0.0, 0.0, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}'.count
E        +      where '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    float x;\n\n    float x = 1.0;\n    return vec4(x, 0.0, 0.0, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}' = ShaderResult(fragment_source='#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    fl... in vec2 in_uv;\nout vec2 vs_uv;\n\nvoid main() {\n    gl_Position = vec4(in_pos, 0.0, 1.0);\n    vs_uv = in_uv;\n}\n').fragment_source

tests/test_shader_hoisting.py:164: AssertionError
------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------
2025-02-10 16:23:52.073 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        x = 1.0  # Should be hoisted and initialized in one statement
        return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:52.073 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    x = 1.0  # Should be hoisted and initialized in one statement
    return vec4(x, 0.0, 0.0, 1.0)

2025-02-10 16:23:52.073 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:52.073 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=1.0)),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Constant(value=0.0),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:52.073 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:52.073 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    float x;

    float x = 1.0;
    return vec4(x, 0.0, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:52.073 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
_________________________________________________________________________ test_hoisting_multiple_variables __________________________________________________________________________

    def test_hoisting_multiple_variables():
        """Test multiple variables are hoisted correctly without redeclaration"""
    
        def shader(vs_uv: vec2) -> vec4:
            x = 1.0
            y = 2.0
            z = x + y
            return vec4(x, y, z, 1.0)
    
        result = py2glsl(shader)
>       assert result.fragment_source.count("float x") == 1
E       AssertionError: assert 2 == 1
E        +  where 2 = <built-in method count of str object at 0x7fd25351a040>('float x')
E        +    where <built-in method count of str object at 0x7fd25351a040> = '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    float x;\n    float y;\n    flo... y = 2.0;\n    float z = x + y;\n    return vec4(x, y, z, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}'.count
E        +      where '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    float x;\n    float y;\n    flo... y = 2.0;\n    float z = x + y;\n    return vec4(x, y, z, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}' = ShaderResult(fragment_source='#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    fl... in vec2 in_uv;\nout vec2 vs_uv;\n\nvoid main() {\n    gl_Position = vec4(in_pos, 0.0, 1.0);\n    vs_uv = in_uv;\n}\n').fragment_source

tests/test_shader_hoisting.py:181: AssertionError
------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------
2025-02-10 16:23:52.077 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        x = 1.0
        y = 2.0
        z = x + y
        return vec4(x, y, z, 1.0)

2025-02-10 16:23:52.077 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    x = 1.0
    y = 2.0
    z = x + y
    return vec4(x, y, z, 1.0)

2025-02-10 16:23:52.077 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:52.077 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Constant(value=1.0)),
        Assign(
          targets=[
            Name(id='y', ctx=Store())],
          value=Constant(value=2.0)),
        Assign(
          targets=[
            Name(id='z', ctx=Store())],
          value=BinOp(
            left=Name(id='x', ctx=Load()),
            op=Add(),
            right=Name(id='y', ctx=Load()))),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Name(id='y', ctx=Load()),
              Name(id='z', ctx=Load()),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:52.077 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:52.077 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    float x;
    float y;
    float z;

    float x = 1.0;
    float y = 2.0;
    float z = x + y;
    return vec4(x, y, z, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:52.077 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
_______________________________________________________________________ test_hoisting_with_vector_components ________________________________________________________________________

    def test_hoisting_with_vector_components():
        """Test hoisting with vector component assignments"""
    
        def shader(vs_uv: vec2) -> vec4:
            v = vec2(1.0, 2.0)
            x = v.x
            y = v.y
            return vec4(x, y, 0.0, 1.0)
    
        result = py2glsl(shader)
>       assert result.fragment_source.count("vec2 v") == 1
E       AssertionError: assert 4 == 1
E        +  where 4 = <built-in method count of str object at 0x7fd25351a500>('vec2 v')
E        +    where <built-in method count of str object at 0x7fd25351a500> = '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    vec2 v;\n    float x;\n    floa... x = v.x;\n    float y = v.y;\n    return vec4(x, y, 0.0, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}'.count
E        +      where '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    vec2 v;\n    float x;\n    floa... x = v.x;\n    float y = v.y;\n    return vec4(x, y, 0.0, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}' = ShaderResult(fragment_source='#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nvec4 shader(vec2 vs_uv)\n{\n    ve... in vec2 in_uv;\nout vec2 vs_uv;\n\nvoid main() {\n    gl_Position = vec4(in_pos, 0.0, 1.0);\n    vs_uv = in_uv;\n}\n').fragment_source

tests/test_shader_hoisting.py:200: AssertionError
------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------
2025-02-10 16:23:52.080 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2) -> vec4:
        v = vec2(1.0, 2.0)
        x = v.x
        y = v.y
        return vec4(x, y, 0.0, 1.0)

2025-02-10 16:23:52.080 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2) -> vec4:
    v = vec2(1.0, 2.0)
    x = v.x
    y = v.y
    return vec4(x, y, 0.0, 1.0)

2025-02-10 16:23:52.080 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:52.080 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))]),
      body=[
        Assign(
          targets=[
            Name(id='v', ctx=Store())],
          value=Call(
            func=Name(id='vec2', ctx=Load()),
            args=[
              Constant(value=1.0),
              Constant(value=2.0)])),
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Attribute(
            value=Name(id='v', ctx=Load()),
            attr='x',
            ctx=Load())),
        Assign(
          targets=[
            Name(id='y', ctx=Store())],
          value=Attribute(
            value=Name(id='v', ctx=Load()),
            attr='y',
            ctx=Load())),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Name(id='y', ctx=Load()),
              Constant(value=0.0),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:52.080 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:52.080 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

vec4 shader(vec2 vs_uv)
{
    vec2 v;
    float x;
    float y;

    vec2 v = vec2(1.0, 2.0);
    float x = v.x;
    float y = v.y;
    return vec4(x, y, 0.0, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:52.080 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {}
______________________________________________________________________ test_hoisting_with_complex_expressions _______________________________________________________________________

    def test_hoisting_with_complex_expressions():
        """Test hoisting with more complex expressions similar to failing shader"""
    
        def shader(vs_uv: vec2, *, u_time: float = 0.0) -> vec4:
            x = sin(u_time)
            y = x * 2.0
            z = smoothstep(0.0, 1.0, y)
            return vec4(x, y, z, 1.0)
    
        result = py2glsl(shader)
>       assert result.fragment_source.count("float x") == 1
E       AssertionError: assert 2 == 1
E        +  where 2 = <built-in method count of str object at 0x7fd253b8a810>('float x')
E        +    where <built-in method count of str object at 0x7fd253b8a810> = '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nuniform float u_time;\n\nvec4 shader(vec2 vs_uv)\n{\n    float ...at z = smoothstep(0.0, 1.0, y);\n    return vec4(x, y, z, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}'.count
E        +      where '#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nuniform float u_time;\n\nvec4 shader(vec2 vs_uv)\n{\n    float ...at z = smoothstep(0.0, 1.0, y);\n    return vec4(x, y, z, 1.0);\n}\n\nvoid main()\n{\n    fs_color = shader(vs_uv);\n}' = ShaderResult(fragment_source='#version 460\n\nin vec2 vs_uv;\nout vec4 fs_color;\n\nuniform float u_time;\n\nvec4 shad... in vec2 in_uv;\nout vec2 vs_uv;\n\nvoid main() {\n    gl_Position = vec4(in_pos, 0.0, 1.0);\n    vs_uv = in_uv;\n}\n').fragment_source

tests/test_shader_hoisting.py:219: AssertionError
------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------
2025-02-10 16:23:52.083 | DEBUG    | py2glsl.transpiler:py2glsl:31 - Original source:
    def shader(vs_uv: vec2, *, u_time: float = 0.0) -> vec4:
        x = sin(u_time)
        y = x * 2.0
        z = smoothstep(0.0, 1.0, y)
        return vec4(x, y, z, 1.0)

2025-02-10 16:23:52.084 | DEBUG    | py2glsl.transpiler:py2glsl:35 - After dedent:
def shader(vs_uv: vec2, *, u_time: float = 0.0) -> vec4:
    x = sin(u_time)
    y = x * 2.0
    z = smoothstep(0.0, 1.0, y)
    return vec4(x, y, z, 1.0)

2025-02-10 16:23:52.084 | DEBUG    | py2glsl.transpiler:py2glsl:40 - Successfully parsed AST
2025-02-10 16:23:52.084 | DEBUG    | py2glsl.transpiler:py2glsl:55 - Extracted function AST:
Module(
  body=[
    FunctionDef(
      name='shader',
      args=arguments(
        args=[
          arg(
            arg='vs_uv',
            annotation=Name(id='vec2', ctx=Load()))],
        kwonlyargs=[
          arg(
            arg='u_time',
            annotation=Name(id='float', ctx=Load()))],
        kw_defaults=[
          Constant(value=0.0)]),
      body=[
        Assign(
          targets=[
            Name(id='x', ctx=Store())],
          value=Call(
            func=Name(id='sin', ctx=Load()),
            args=[
              Name(id='u_time', ctx=Load())])),
        Assign(
          targets=[
            Name(id='y', ctx=Store())],
          value=BinOp(
            left=Name(id='x', ctx=Load()),
            op=Mult(),
            right=Constant(value=2.0))),
        Assign(
          targets=[
            Name(id='z', ctx=Store())],
          value=Call(
            func=Name(id='smoothstep', ctx=Load()),
            args=[
              Constant(value=0.0),
              Constant(value=1.0),
              Name(id='y', ctx=Load())])),
        Return(
          value=Call(
            func=Name(id='vec4', ctx=Load()),
            args=[
              Name(id='x', ctx=Load()),
              Name(id='y', ctx=Load()),
              Name(id='z', ctx=Load()),
              Constant(value=1.0)]))],
      returns=Name(id='vec4', ctx=Load()))])
2025-02-10 16:23:52.084 | DEBUG    | py2glsl.transpiler.analyzer:analyze:317 - Found function definition: shader
2025-02-10 16:23:52.084 | DEBUG    | py2glsl.transpiler:py2glsl:83 - Generated GLSL:
#version 460

in vec2 vs_uv;
out vec4 fs_color;

uniform float u_time;

vec4 shader(vec2 vs_uv)
{
    float x;
    float y;
    float z;

    float x = sin(u_time);
    float y = x * 2.0;
    float z = smoothstep(0.0, 1.0, y);
    return vec4(x, y, z, 1.0);
}

void main()
{
    fs_color = shader(vs_uv);
}
2025-02-10 16:23:52.084 | DEBUG    | py2glsl.transpiler:py2glsl:93 - Extracted uniforms: {'u_time': 'float'}
================================================================================= warnings summary ==================================================================================
tests/test_shader_hoisting.py: 46 warnings
  /home/akarnachev/proj/py2glsl/py2glsl/transpiler/analyzer.py:112: DeprecationWarning: ast.Num is deprecated and will be removed in Python 3.14; use ast.Constant instead
    elif isinstance(node, ast.Num):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
============================================================================== short test summary info ==============================================================================
FAILED tests/test_shader_hoisting.py::test_basic_variable_hoisting - _moderngl.Error: GLSL Compiler failed
FAILED tests/test_shader_hoisting.py::test_loop_scope_hoisting - _moderngl.Error: GLSL Compiler failed
FAILED tests/test_shader_hoisting.py::test_multiple_variable_hoisting - _moderngl.Error: GLSL Compiler failed
FAILED tests/test_shader_hoisting.py::test_function_scope_isolation - _moderngl.Error: GLSL Compiler failed
FAILED tests/test_shader_hoisting.py::test_reused_variable_single_declaration - _moderngl.Error: GLSL Compiler failed
FAILED tests/test_shader_hoisting.py::test_hoisting_with_immediate_init - AssertionError: assert 2 == 1
FAILED tests/test_shader_hoisting.py::test_hoisting_multiple_variables - AssertionError: assert 2 == 1
FAILED tests/test_shader_hoisting.py::test_hoisting_with_vector_components - AssertionError: assert 4 == 1
FAILED tests/test_shader_hoisting.py::test_hoisting_with_complex_expressions - AssertionError: assert 2 == 1
===================================================================== 9 failed, 2 passed, 46 warnings in 0.55s ======================================================================

