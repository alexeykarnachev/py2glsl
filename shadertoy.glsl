// Generated by py2glsl v1.0.0
// Generation time: 2025-03-25 08:54:56 UTC
// Source file: raymarching.py
// Target: SHADERTOY
// Shadertoy-compatible: Built-in uniforms removed

const float NORMAL_DERIVATIVE_STEP = 0.015;
const float PI = 3.141592;
const float RM_EPS = 0.0001;
const float RM_MAX_DIST = 10000.0;
const int RM_MAX_STEPS = 64;

struct RayMarchResult {
    int steps;
    vec3 p;
    vec3 normal;
    vec3 ro;
    vec3 rd;
    float dist;
    float sd_last;
    float sd_min;
    float sd_min_shape;
    bool has_normal;
};

float get_sd_shape(vec3 p) {
    float d = length(max(abs(p) - vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0))) - 0.2;
    return d;
}

RayMarchResult march(vec3 ro, vec3 rd) {
    RayMarchResult rm = RayMarchResult(0, ro, vec3(0.0, 0.0, 0.0), ro, rd, 0.0, 0.0, RM_MAX_DIST, RM_MAX_DIST, false);
    for (int i = 0; i < RM_MAX_STEPS; i += 1) {
        rm.steps = i;
        rm.p = rm.p + rm.rd * rm.sd_last;
        float sd_step_shape = get_sd_shape(rm.p);
        rm.sd_last = sd_step_shape;
        rm.sd_min_shape = min(rm.sd_min_shape, sd_step_shape);
        rm.sd_min = min(rm.sd_min, sd_step_shape);
        rm.dist = rm.dist + length(rm.p - rm.ro);
        if (rm.sd_last < RM_EPS || rm.dist > RM_MAX_DIST) {
            break;
        }
    }
    if (rm.sd_last < RM_EPS) {
        vec2 e = vec2(NORMAL_DERIVATIVE_STEP, 0.0);
        rm.normal = normalize(vec3(get_sd_shape(rm.p + vec3(e.x, 0.0, 0.0)) - get_sd_shape(rm.p - vec3(e.x, 0.0, 0.0)), get_sd_shape(rm.p + vec3(0.0, e.x, 0.0)) - get_sd_shape(rm.p - vec3(0.0, e.x, 0.0)), get_sd_shape(rm.p + vec3(0.0, 0.0, e.x)) - get_sd_shape(rm.p - vec3(0.0, 0.0, e.x))));
        rm.has_normal = true;
    }
    return rm;
}

float attenuate(float d, vec3 coeffs) {
    return 1.0 / (coeffs.x + coeffs.y * d + coeffs.z * d * d);
}

vec4 shader(vec2 vs_uv, float u_time, float u_aspect) {
    vec2 screen_pos = vs_uv * 2.0 - vec2(1.0, 1.0);
    screen_pos.x = screen_pos.x * u_aspect;
    float fov = radians(70.0);
    float screen_dist = 1.0 / tan(0.5 * fov);
    float animation_speed = 0.3;
    float camera_height = 5.0;
    float camera_distance = 5.0;
    float angle = u_time * animation_speed;
    vec3 cam_pos = vec3(camera_distance * sin(angle), camera_height, camera_distance * cos(angle));
    vec3 look_at = vec3(0.0, 0.0, 0.0);
    vec3 forward = normalize(look_at - cam_pos);
    vec3 world_up = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(forward, world_up));
    vec3 up = normalize(cross(right, forward));
    vec3 screen_center = cam_pos + forward * screen_dist;
    vec3 sp = screen_center + right * screen_pos.x + up * screen_pos.y;
    vec3 ro = cam_pos;
    vec3 rd = normalize(sp - cam_pos);
    RayMarchResult rm = march(ro, rd);
    vec3 color = vec3(0.0, 0.0, 0.0);
    if (rm.has_normal) {
        color = abs(rm.normal);
        float d = abs(max(0.0, rm.sd_min_shape));
        float a = attenuate(d, vec3(0.01, 8.0, 8.0));
        color = color * a;
    } else {
        color = vec3(0.1, 0.2, 0.3) * (1.0 - length(screen_pos) * 0.5);
    }
    return vec4(color.x, color.y, color.z, 1.0);
}


// Shadertoy compatible mainImage function
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    // Transform Shadertoy coordinates to UV coordinates
    vec2 vs_uv = fragCoord / iResolution.xy;
    vec4 result = shader(vs_uv, iTime, iResolution.x / iResolution.y);
    fragColor = result;
}
