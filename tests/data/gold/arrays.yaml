- name: list_as_vec2
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        v = [1.0, 2.0]
        return vec4(v.x, v.y, 0.0, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec2 v = vec2(1.0, 2.0);
        return vec4(v.x, v.y, 0.0, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: list_as_vec3
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        v = [1.0, 2.0, 3.0]
        return vec4(v[0], v[1], v[2], 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec3 v = vec3(1.0, 2.0, 3.0);
        return vec4(v[0], v[1], v[2], 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: list_as_vec4
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        v = [1.0, 2.0, 3.0, 4.0]
        return v
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec4 v = vec4(1.0, 2.0, 3.0, 4.0);
        return v;
    }

    void main() {
        fragColor = shader();
    }
- name: list_vec_swizzle
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        v = [1.0, 2.0, 3.0]
        return vec4(v.xy, v.z, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec3 v = vec3(1.0, 2.0, 3.0);
        return vec4(v.xy, v.z, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_float_basic
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        weights: array[float, 3] = [0.2, 0.5, 0.3]
        return vec4(weights[0], weights[1], weights[2], 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        float weights[3] = float[3](0.2, 0.5, 0.3);
        return vec4(weights[0], weights[1], weights[2], 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_float_large
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        data: array[float, 8] = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]
        return vec4(data[0], data[4], data[7], 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        float data[8] = float[8](0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8);
        return vec4(data[0], data[4], data[7], 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_vec3
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        colors: array[vec3, 3] = [
            vec3(1.0, 0.0, 0.0),
            vec3(0.0, 1.0, 0.0),
            vec3(0.0, 0.0, 1.0)
        ]
        return vec4(colors[0], 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec3 colors[3] = vec3[3](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));
        return vec4(colors[0], 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_dynamic_index
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        values: array[float, 4] = [0.25, 0.5, 0.75, 1.0]
        i: int = 2
        return vec4(values[i], 0.0, 0.0, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        float values[4] = float[4](0.25, 0.5, 0.75, 1.0);
        int i = 2;
        return vec4(values[i], 0.0, 0.0, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_element_assign
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        arr: array[float, 3] = [1.0, 2.0, 3.0]
        arr[0] = 5.0
        return vec4(arr[0], arr[1], arr[2], 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        float arr[3] = float[3](1.0, 2.0, 3.0);
        arr[0] = 5.0;
        return vec4(arr[0], arr[1], arr[2], 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_loop_access
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        weights: array[float, 4] = [0.1, 0.2, 0.3, 0.4]
        total: float = 0.0
        for i in range(4):
            total += weights[i]
        return vec4(total, 0.0, 0.0, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        float weights[4] = float[4](0.1, 0.2, 0.3, 0.4);
        float total = 0.0;
        for (int i = 0; i < 4; i += 1) {
            total += weights[i];
        }
        return vec4(total, 0.0, 0.0, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_in_expression
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        offsets: array[float, 3] = [0.1, 0.2, 0.3]
        result = ctx.vs_uv.x + offsets[0] * offsets[1]
        return vec4(result, 0.0, 0.0, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        float offsets[3] = float[3](0.1, 0.2, 0.3);
        float result = vs_uv.x + offsets[0] * offsets[1];
        return vec4(result, 0.0, 0.0, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_int
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        indices: array[int, 3] = [0, 1, 2]
        return vec4(float(indices[0]), float(indices[1]), float(indices[2]), 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        int indices[3] = int[3](0, 1, 2);
        return vec4(float(indices[0]), float(indices[1]), float(indices[2]), 1.0);
    }

    void main() {
        fragColor = shader();
    }
# Negative indexing
- name: negative_index_vec4
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        v = vec4(1.0, 2.0, 3.0, 4.0)
        last = v[-1]
        second_last = v[-2]
        return vec4(last, second_last, 0.0, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec4 v = vec4(1.0, 2.0, 3.0, 4.0);
        float last = v[3];
        float second_last = v[2];
        return vec4(last, second_last, 0.0, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: negative_index_array
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        arr: array[float, 4] = [1.0, 2.0, 3.0, 4.0]
        last = arr[-1]
        first = arr[-4]
        return vec4(last, first, 0.0, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        float arr[4] = float[4](1.0, 2.0, 3.0, 4.0);
        float last = arr[3];
        float first = arr[0];
        return vec4(last, first, 0.0, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: negative_index_vec3
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        v = vec3(1.0, 2.0, 3.0)
        return vec4(v[-1], v[-2], v[-3], 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec3 v = vec3(1.0, 2.0, 3.0);
        return vec4(v[2], v[1], v[0], 1.0);
    }

    void main() {
        fragColor = shader();
    }
# Array element type inference (subscript should return element type, not float)
- name: array_vec3_element_type
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        colors: array[vec3, 3] = [
            vec3(1.0, 0.0, 0.0),
            vec3(0.0, 1.0, 0.0),
            vec3(0.0, 0.0, 1.0)
        ]
        c = colors[1]
        return vec4(c, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec3 colors[3] = vec3[3](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));
        vec3 c = colors[1];
        return vec4(c, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_vec3_negative_index_type
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        colors: array[vec3, 4] = [
            vec3(1.0, 0.0, 0.0),
            vec3(0.0, 1.0, 0.0),
            vec3(0.0, 0.0, 1.0),
            vec3(1.0, 1.0, 0.0)
        ]
        last = colors[-1]
        second_last = colors[-2]
        return vec4(last.r, second_last.g, 0.0, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec3 colors[4] = vec3[4](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 0.0));
        vec3 last = colors[3];
        vec3 second_last = colors[2];
        return vec4(last.r, second_last.g, 0.0, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_vec2_element_type
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        points: array[vec2, 2] = [
            vec2(0.0, 0.0),
            vec2(1.0, 1.0)
        ]
        p = points[0]
        return vec4(p.x, p.y, 0.0, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec2 points[2] = vec2[2](vec2(0.0, 0.0), vec2(1.0, 1.0));
        vec2 p = points[0];
        return vec4(p.x, p.y, 0.0, 1.0);
    }

    void main() {
        fragColor = shader();
    }
- name: array_vec4_element_type
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        quads: array[vec4, 2] = [
            vec4(1.0, 0.0, 0.0, 1.0),
            vec4(0.0, 1.0, 0.0, 1.0)
        ]
        q = quads[-1]
        return q
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec4 quads[2] = vec4[2](vec4(1.0, 0.0, 0.0, 1.0), vec4(0.0, 1.0, 0.0, 1.0));
        vec4 q = quads[1];
        return q;
    }

    void main() {
        fragColor = shader();
    }
- name: array_vec3_in_if_branch
  python: |
    def shader(ctx: ShaderContext) -> vec4:
        colors: array[vec3, 2] = [
            vec3(1.0, 0.0, 0.0),
            vec3(0.0, 1.0, 0.0)
        ]
        if ctx.vs_uv.x > 0.5:
            c = colors[0]
        else:
            c = colors[1]
        return vec4(c, 1.0)
  expected: |
    #version 460 core

    in vec2 vs_uv;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_aspect;
    uniform vec2 u_mouse_pos;
    uniform vec2 u_mouse_uv;
    out vec4 fragColor;

    vec4 shader() {
        vec3 colors[2] = vec3[2](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
        vec3 c;
        if (vs_uv.x > 0.5) {
            c = colors[0];
        } else {
            c = colors[1];
        }
        return vec4(c, 1.0);
    }

    void main() {
        fragColor = shader();
    }
